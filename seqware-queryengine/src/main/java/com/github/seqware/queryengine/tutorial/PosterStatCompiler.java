/*
 * Copyright (C) 2012 SeqWare
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package com.github.seqware.queryengine.tutorial;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.SortedMap;
import java.util.TreeMap;
import org.apache.log4j.Logger;


/**
 * This program compiles information generated by the {@link Poster} class.
 * 
 * 
 * @author dyuen
 */
public class PosterStatCompiler {
    
    public static void main(String[] args){
        try {
            BufferedReader in = new BufferedReader(new FileReader(args[0]));
            // read entire buffer
            SortedMap<Integer, Map<String, String>> countedMaps = new TreeMap<Integer, Map<String, String>>();
            Map<String, String> baseKeys = new HashMap<String, String>();
            
            while(in.ready()){
                String line = in.readLine();
                String[] tabSplit = line.split("\t");
                String[] dashSplit = tabSplit[0].split("-");
                try{
                    Integer count = Integer.valueOf(dashSplit[0]);
                    if (!countedMaps.containsKey(count)){
                        countedMaps.put(count, new HashMap<String, String>());
                    }
                    // create value
                    String substring = tabSplit[0].substring(tabSplit[0].indexOf("-")+1);
                    countedMaps.get(count).put(substring, tabSplit[1]);
                } catch(NumberFormatException nE){
                    // process as a baseKey
                    baseKeys.put(tabSplit[0], tabSplit[1]);
                }   
            }
            
            // process and create statistics
             PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
             out.println("Batch Count\tFeatures\tFeature Space Used\tCumulative Loading Time(seconds)\tQuery Time for Count(seconds)");
             
             // prime pump
             int startSpace;
             if (!baseKeys.containsKey("start-feature-space-in-GB")){
                 startSpace = 0;
             } else{
                startSpace = Integer.valueOf(baseKeys.get("start-feature-space-in-GB"));
             }
             int cumulativeLoadingTime = 0;
             
             // go through remaining keys
             for(Entry<Integer, Map<String, String>> e : countedMaps.entrySet()){
                 int count = e.getKey();
                 String featureCount = e.getValue().get("features-loaded");
                 float featureSpaceUsed = Integer.valueOf(e.getValue().get("feature-space-in-GB")) - startSpace;
                 long batchLoadingTime = Long.valueOf(e.getValue().get("start-count-date-long")) - Long.valueOf(e.getValue().get("start-date-long"));
                 cumulativeLoadingTime += batchLoadingTime;
                 long queryTime = Long.valueOf(e.getValue().get("end-count-date-long")) - Long.valueOf(e.getValue().get("start-count-date-long"));
                 out.println(count+"\t"+featureCount+"\t"+featureSpaceUsed+"\t"+cumulativeLoadingTime/1000+"\t"+queryTime/1000);
             }
             out.close();
        } catch (FileNotFoundException ex) {
            Logger.getLogger(PosterStatCompiler.class.getName()).fatal(null, ex);
        } catch (IOException ex) {
            Logger.getLogger(PosterStatCompiler.class.getName()).fatal(null, ex);
        }
        
    }
}
