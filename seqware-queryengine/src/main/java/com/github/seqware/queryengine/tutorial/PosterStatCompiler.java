/*
 * Copyright (C) 2012 SeqWare
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package com.github.seqware.queryengine.tutorial;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.SortedMap;
import java.util.TreeMap;
import org.apache.log4j.Logger;


/**
 * This program compiles information generated by the {@link com.github.seqware.queryengine.tutorial.Poster} class.
 *
 * @author dyuen
 * @version $Id: $Id
 */
public class PosterStatCompiler {
    /** Constant <code>START_PMC_QUERYDATELONG="start-PMC_query-date-long"</code> */
    public static final String START_PMC_QUERYDATELONG = "start-PMC_query-date-long";
    /** Constant <code>START_PMCSI_QUERYDATELONG="start-PMCSI_query-date-long"</code> */
    public static final String START_PMCSI_QUERYDATELONG = "start-PMCSI_query-date-long";
    /** Constant <code>START_QUAL_QUERYDATELONG="start-QUAL_query-date-long"</code> */
    public static final String START_QUAL_QUERYDATELONG = "start-QUAL_query-date-long";
    /** Constant <code>START_ALL_QUERYDATELONG="start-ALL_query-date-long"</code> */
    public static final String START_ALL_QUERYDATELONG = "start-ALL_query-date-long";
    /** Constant <code>STARTDUMP_QUERYDATELONG="start-dump_query-date-long"</code> */
    public static final String STARTDUMP_QUERYDATELONG = "start-dump_query-date-long";
    /** Constant <code>STARTCOUNTDATELONG="start-count-date-long"</code> */
    public static final String STARTCOUNTDATELONG = "start-count-date-long";
    /** Constant <code>END_PMC_QUERYDATELONG="end-PMC_query-date-long"</code> */
    public static final String END_PMC_QUERYDATELONG = "end-PMC_query-date-long";
    /** Constant <code>END_QUAL_QUERYDATELONG="end-QUAL_query-date-long"</code> */
    public static final String END_QUAL_QUERYDATELONG = "end-QUAL_query-date-long";
    /** Constant <code>END_ALL_QUERYDATELONG="end-ALL_query-date-long"</code> */
    public static final String END_ALL_QUERYDATELONG = "end-ALL_query-date-long";
    
    /**
     * <p>main.</p>
     *
     * @param args an array of {@link java.lang.String} objects.
     */
    public static void main(String[] args){
        try {
            BufferedReader in = new BufferedReader(new FileReader(args[0]));
            // read entire buffer
            SortedMap<Integer, Map<String, String>> countedMaps = new TreeMap<Integer, Map<String, String>>();
            Map<String, String> baseKeys = new HashMap<String, String>();
            
            while(in.ready()){
                String line = in.readLine();
                String[] tabSplit = line.split("\t");
                String[] dashSplit = tabSplit[0].split("-");
                try{
                    Integer count = Integer.valueOf(dashSplit[0]);
                    if (!countedMaps.containsKey(count)){
                        countedMaps.put(count, new HashMap<String, String>());
                    }
                    // create value
                    String substring = tabSplit[0].substring(tabSplit[0].indexOf("-")+1);
                    countedMaps.get(count).put(substring, tabSplit[1]);
                } catch(NumberFormatException nE){
                    // process as a baseKey
                    baseKeys.put(tabSplit[0], tabSplit[1]);
                }   
            }
            
            // print overall stat in case counts fail
            long overallTime = Long.valueOf(countedMaps.get(0).get("end-date-long")) - Long.valueOf(countedMaps.get(0).get("start-date-long"));
            System.out.println(overallTime/1000);
            System.exit(0);
            
            // process and create statistics
             PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
             out.print("Batch Count\tFeatures\tFeature Space Used\tCumulative Loading Time(seconds)\tQuery Time for Count(seconds)");
             if (countedMaps.get(0).containsKey(START_PMC_QUERYDATELONG)){
                 out.print("\tPMC Query Time (seconds)\tPMC Features Copied\tPMC count time (seconds)");
             }
             if (countedMaps.get(0).containsKey(START_PMCSI_QUERYDATELONG)){
                 out.print("\tPMCSI Query Time (seconds)\tPMCSI Features Copied");
             }
             if (countedMaps.get(0).containsKey(START_QUAL_QUERYDATELONG)){
                 out.print("\tQUAL Query Time (seconds)\tQUAL Features Copied\tQUAL count time (seconds)");
             }
             if (countedMaps.get(0).containsKey(START_ALL_QUERYDATELONG)){
                 out.print("\tALL-copy Query Time (seconds)\tALL-copy Features Copied\tALL-copy count time (seconds)");
             }
             if (countedMaps.get(0).containsKey(STARTDUMP_QUERYDATELONG)){
                 out.print("\tVCFDump Query Time (seconds)");
             }
             out.println();
             // prime pump
             int startSpace;
             if (!baseKeys.containsKey("start-feature-space-in-GB")){
                 startSpace = 0;
             } else{
                startSpace = Integer.valueOf(baseKeys.get("start-feature-space-in-GB"));
             }
             int cumulativeLoadingTime = 0;
             
             // go through remaining keys
             for(Entry<Integer, Map<String, String>> e : countedMaps.entrySet()){
                 int count = e.getKey();
                 String featureCount = e.getValue().get("features-loaded");
                 float featureSpaceUsed = Integer.valueOf(e.getValue().get("feature-space-in-GB")) - startSpace;
                 long batchLoadingTime = Long.valueOf(e.getValue().get(STARTCOUNTDATELONG)) - Long.valueOf(e.getValue().get("start-date-long"));
                 cumulativeLoadingTime += batchLoadingTime;
                 long queryTime = Long.valueOf(e.getValue().get("end-count-date-long")) - Long.valueOf(e.getValue().get(STARTCOUNTDATELONG));
                 out.print(count+"\t"+featureCount+"\t"+featureSpaceUsed+"\t"+cumulativeLoadingTime/1000+"\t"+queryTime/1000);
                 // if PMC is available
                 if (e.getValue().containsKey(START_PMC_QUERYDATELONG)){
                     long qTime = Long.valueOf(e.getValue().get(END_PMC_QUERYDATELONG)) - Long.valueOf(e.getValue().get(START_PMC_QUERYDATELONG));
                     long features = Long.valueOf(e.getValue().get("features-PMC_query-written"));
                     long countTime = Long.valueOf(e.getValue().get("end-PMC_query-count-date-long")) - Long.valueOf(e.getValue().get(END_PMC_QUERYDATELONG));
                     out.print("\t" + qTime/1000 + "\t" + features + "\t" + countTime/1000);
                 } 
                 // if PMCSI is available
                 if (e.getValue().containsKey(START_PMCSI_QUERYDATELONG)){
                     long qTime = Long.valueOf(e.getValue().get("end-PMCSI_query-date-long")) - Long.valueOf(e.getValue().get(START_PMCSI_QUERYDATELONG));
                     long features = Long.valueOf(e.getValue().get("features-PMCSI_query-written"));
                     out.print("\t" + qTime/1000 + "\t" + features);
                 } 
                 // if QUAL is available
                 if (e.getValue().containsKey(START_QUAL_QUERYDATELONG)){
                     long qTime = Long.valueOf(e.getValue().get(END_QUAL_QUERYDATELONG)) - Long.valueOf(e.getValue().get(START_QUAL_QUERYDATELONG));
                     long features = Long.valueOf(e.getValue().get("features-QUAL_query-written"));
                     long countTime = Long.valueOf(e.getValue().get("end-QUAL_query-count-date-long")) - Long.valueOf(e.getValue().get(END_QUAL_QUERYDATELONG));
                     out.print("\t" + qTime/1000 + "\t" + features + "\t" + countTime/1000);
                 } 
                 // if COPY_ALL is available
                 if (e.getValue().containsKey(START_ALL_QUERYDATELONG)){
                     long qTime = Long.valueOf(e.getValue().get(END_ALL_QUERYDATELONG)) - Long.valueOf(e.getValue().get(START_ALL_QUERYDATELONG));
                     long features = Long.valueOf(e.getValue().get("features-ALL_query-written"));
                     long countTime = Long.valueOf(e.getValue().get("end-QUAL_query-count-date-long")) - Long.valueOf(e.getValue().get(END_ALL_QUERYDATELONG));
                     out.print("\t" + qTime/1000 + "\t" + features + "\t" + countTime/1000);
                 } 
                 // if DUMP is available
                 if (e.getValue().containsKey(STARTDUMP_QUERYDATELONG)){
                     long qTime = Long.valueOf(e.getValue().get("end-dump_query-count-date-long")) - Long.valueOf(e.getValue().get(STARTDUMP_QUERYDATELONG));
                     out.print("\t" + qTime/1000);
                 }
                 out.println();
             }
             out.close();
        } catch (FileNotFoundException ex) {
            Logger.getLogger(PosterStatCompiler.class.getName()).fatal(null, ex);
        } catch (IOException ex) {
            Logger.getLogger(PosterStatCompiler.class.getName()).fatal(null, ex);
        }
        
    }
}
